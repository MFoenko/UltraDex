package com.mikhail.pokedex.data;

import android.content.*;
import android.database.*;
import android.database.sqlite.*;
import android.graphics.*;
import android.util.*;
import java.io.*;
import java.text.*;
import java.util.*;
import com.mikhail.pokedex.data.PokedexClasses.*;


public class PokedexDatabase extends SQLiteOpenHelper {

	private static String DB_PATH = "/data/data/com.mikhail.pokedex/databases/";

	private static String DB_NAME = "veekun-pokedex.sqlite";
	public static final int DB_VERSION = 1;

	private SQLiteDatabase dex; 

	public static final int LANG_ID_ENGLISH = 9;
	public static final int VERSION_GROUP = 15;
	public static final String TABLE_POKEMON_NAMES = "pokemon_species_names";

	public static final String TABLE_POKEMON = "pokemon";
	public static final String TABLE_POKEMON_STATS = "pokemon_stats";
	public static final String TABLE_POKEMON_TYPES = "pokemon_types";

	public static final String[] MOVE_METHOD_NAMES = new String[]{"Lvl\n", "Egg", "Tutor", "TM/HM", "", "", "", "", "", "Rotom Form"};
	public static final String[] DAMAGE_CLASS_NAMES = new String[]{"Status", "Physical", "Special"};
	public static final String[] STAT_LABELS = new String[]{"HP", "Attack", "Defense", "Sp. Attack", "Sp. Defence", "Speed"};
	public static final int[] STAT_COLORS = new int[]{0xFF0000, 0xFFA500, 0xFFFF00, 0x1E90FF, 0x008000, 0xFFC0CB };
	public static final String[] EVOLVE_METHODS = new String[]{"", "Level Up", "Trade", "Item", "Shed"};

	public int currentTypeGen;
	public String[] typeNames;
	public static int[] typeColors = new int[]{0xFFA8A77A, 0xFFC22E28, 0xFFA98FF3, 0xFFA33EA1, 0xFFE2BF65, 0xFFB6A136, 0xFFA6B91A, 0xFF735797, 0xFFB7B7CE, 0xFFEE8130, 0xFF6390F0, 0xFF7AC74C, 0xFFF7D02C, 0xFFF95587, 0xFF96D9D6, 0xFF6F35FC, 0xFF705746, Color.MAGENTA};
	public float[][] typeEfficiancy;


	public PokedexDatabase(Context context) {

		super(context, DB_NAME, null, DB_VERSION);
		this.myContext = context;

        openDataBase();
		int lang = LANG_ID_ENGLISH;
		Cursor c = dex.rawQuery("SELECT name FROM type_names WHERE local_language_id= ? ORDER BY type_id;", new String[]{"" + lang});

		c.moveToFirst();
		typeNames = new String[c.getCount()];
		for (int i=0;i < typeNames.length;i++) {
			typeNames[i] = c.getString(0);
			c.moveToNext();
		}
	}	

	public PokedexListItem[] getAllPokedexListItems() {return getAllPokedexListItems(LANG_ID_ENGLISH);}

	public PokedexListItem[] getAllPokedexListItems(int lang) {return getAllPokedexListItems(lang, "pokemon_species_id");}

	public PokedexListItem[] getAllPokedexListItems(String sortBy) {return getAllPokedexListItems(LANG_ID_ENGLISH, sortBy);}

	public PokedexListItem[] getAllPokedexListItems(int lang, String sortBy) {
		if (dex == null)
			return null;

		String query = "SELECT pokemon_species_id, name FROM " + TABLE_POKEMON_NAMES + " WHERE local_language_id = " + lang + " ORDER BY " + sortBy + ";";
		Cursor c = dex.rawQuery(query, null);

		PokedexListItem[] items = null;

		if (c.moveToFirst()) {
			DecimalFormat df = new DecimalFormat("000");
			items = new PokedexListItem[c.getCount()];
			for (int i=0;i < items.length;i++) {
				items[i] = new PokedexListItem(c.getInt(0), df.format(c.getInt(0)), c.getString(1));
				c.moveToNext();
			}
		}
		c.close();

		return items;
	}

	public PokedexListItem getPokedexListItem(int id, int lang) {
		String query;
		if (id < 10000) {
			query = "SELECT pokemon_species_id, name FROM " + TABLE_POKEMON_NAMES + " WHERE pokemon_species_id = ? AND local_language_id = ?;";			
		} else {
			query = "SELECT pokemon_form_id, pokemon_name FROM pokemon_form_names WHERE pokemon_form_id = ? AND local_language_id = ?;";			
		}
		Cursor c = dex.rawQuery(query, new String[]{String.valueOf(id), String.valueOf(lang)});
		c.moveToFirst();
		PokedexListItem item = new PokedexListItem(c.getInt(0), c.getString(0), c.getString(1));
		c.close();
		return item;
	}

	public PokedexEntry[] getAllPokedexEntriesArray() {
		return getAllPokedexEntriesArray(LANG_ID_ENGLISH);
	}
	public PokedexEntry[] getAllPokedexEntriesArray(int lang) {
		//SELECT (SELECT p.id FROM pokemon_forms as fs join pokemon_forms as p on(p."order" = fs."order" - (fs.form_order-1)) WHERE fs.id = f.id ), form_name, (SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = f.id), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f."order", f.id, f.pokemon_id FROM pokemon_form_names as fn JOIN pokemon_forms as f ON(pokemon_form_id = id) WHERE local_language_id = 9 ORDER BY "order"
		//SELECT (SELECT species_id FROM pokemon WHERE _id = f.pokemon_id), null, IFNULL(form_name, "") || IFNULL((SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = f.pokemon_id),""), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f."order", f.id, f.pokemon_id FROM pokemon_form_names AS fn JOIN pokemon_forms AS f ON(pokemon_form_id = id) WHERE local_language_id = 9 AND pokemon_id= 10034 ORDER BY random()

		String query = "SELECT (SELECT p.id FROM pokemon_forms \"fs\" join pokemon_forms \"p\" on(p.\"order\" = fs.\"order\" - (fs.form_order-1)) WHERE fs.id = f.id ), form_name, (SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = f.id), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f.\"order\", f.id, f.pokemon_id FROM pokemon_form_names \"fn\" JOIN pokemon_forms \"f\" ON(pokemon_form_id = id) WHERE local_language_id = ? AND f.id < 10000 ORDER BY \"order\";";
        Cursor c = this.dex.rawQuery(query, new String[]{String.valueOf(lang)});

		long id;
		String name;

		int[] stats;
		int[] types;

		String dispId;
		int order;
		String suffix;
		DecimalFormat nf = new DecimalFormat("000");

		PokedexEntry[] array = new PokedexEntry[c.getCount()];
		for (int i=0;i < array.length; i++) {
			c.moveToNext();			
			id = c.getLong(0);
			name = c.getString(2);

            dispId = nf.format(c.getInt(8));
            suffix = c.getString(5);
			order = c.getInt(6);
			String[] ss = c.getString(3).split(",");
			stats = new int[6];
			for (int j=0;j < ss.length;j++) {
				stats[j] = Integer.parseInt(ss[j]);
			}
			String[] ts = c.getString(4).split(",");
			types = new int[ts.length];
			for (int j=0;j < ts.length;j++) {
				types[j] = Integer.parseInt(ts[j]) - 1;
			}

			array[i] = new PokedexEntry(id, dispId, name, stats, types, suffix, order);
		}
		c.close();
		return array;

	}

	public PokedexEntry getPokedexEntry(long id) {
		//SELECT (SELECT p.id FROM pokemon_forms AS fs join pokemon_forms AS p on(p."order" = fs."order" - (fs.form_order-1)) WHERE fs.id = f.id ), form_name, (SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = f.id), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f."order", f.id, f.pokemon_id,IFNULL((SELECT *, species_id =_id FROM Pokemon WHERE _id = pokemon_id), 1) FROM pokemon_form_names AS fn JOIN pokemon_forms AS f ON(pokemon_form_id = id) WHERE local_language_id = 9 AND f.id= 716 ORDER BY "order"

		String query = "SELECT (SELECT species_id FROM pokemon WHERE _id = f.pokemon_id) AS poke_id, form_name,  (SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = (SELECT species_id FROM pokemon WHERE _id = f.pokemon_id) ), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f.\"order\", f.id, f.pokemon_id, IFNULL((SELECT species_id =_id FROM Pokemon WHERE _id = pokemon_id), 1)=0 FROM pokemon_form_names AS fn JOIN pokemon_forms AS f ON(pokemon_form_id = id) WHERE local_language_id = 9 AND pokemon_id= ? ORDER BY random()";


		//String query = "SELECT (SELECT p.id FROM pokemon_forms \"fs\" join pokemon_forms \"p\" on(p.\"order\" = fs.\"order\" - (fs.form_order-1)) WHERE fs.id = f.id ), form_name, (SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = f.id), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f.\"order\", f.id, f.pokemon_id FROM pokemon_form_names \"fn\" JOIN pokemon_forms \"f\" ON(pokemon_form_id = id) WHERE local_language_id = 9 AND f.id= ? ORDER BY \"order\";";
        Cursor c = this.dex.rawQuery(query, new String[]{String.valueOf(id)});


		PokedexEntry p = null;
		String name;String formName;

		int[] stats = new int[6];
		int[] types;

		String dispId;
		int order;
		String suffix;
		boolean isDefault;
		boolean hasIcon;

//SELECT id, species id, name, base stats, types, , null, order
		//Cursor c = this.dex.rawQuery("SELECT pokemon_species_id, pokemon_species_id, name, (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = pokemon_species_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = pokemon_species_id GROUP BY pokemon_id), null, \"order\" FROM pokemon_species_names JOIN pokemon ON(pokemon_species_id = species_id) WHERE local_language_id = 7 AND _id < 10000", null);

		//SELECT id, form nsame, species name, stats, type, suffix, order, id, pokeid


		if (c.moveToFirst()) {
            name = c.getString(2);
			formName = c.getString(1);
			DecimalFormat nf = new DecimalFormat("000");
            dispId = nf.format(c.getInt(0));
            suffix = c.getString(5);
			order = c.getInt(6);
			//Furfrou check
			isDefault = id == c.getInt(7)|| id==676;
			hasIcon = c.getInt(9) == 1;
			if (formName != null) {
				name = name + (!hasIcon ? "\n(" : " ") + formName + (!hasIcon ? ")" : ""); 
			}
			String[] ss = c.getString(3).split(",");
			for (int i=0;i < ss.length;i++) {
				stats[i] = Integer.parseInt(ss[i]);
			}
			String[] ts = c.getString(4).split(",");
			types = new int[ts.length];
			for (int i=0;i < ts.length;i++) {
				types[i] = Integer.parseInt(ts[i]) - 1;
			}

			p = new PokedexEntry(id, dispId, name, stats, types, suffix, order, isDefault, hasIcon);

		}

		c.close();

		return p;


	}
	/*
	 public PokedexEntry getPokedexEntry(long l) {
	 int n = 0;
	 String string = new StringBuffer().append(new StringBuffer().append("SELECT (SELECT p.id FROM pokemon_forms \"fs\" join pokemon_forms \"p\" on(p.\"order\" = fs.\"order\" - (fs.form_order-1)) WHERE fs.id = f.id ), form_name, (SELECT name FROM pokemon_species_names WHERE local_language_id = 7 AND pokemon_species_id = f.id), (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = f.pokemon_id GROUP BY pokemon_id), f.form_identifier, f.\"order\", f.id, f.pokemon_id FROM pokemon_form_names \"fn\" JOIN pokemon_forms \"f\" ON(pokemon_form_id = id) WHERE local_language_id = 9 AND f.id=").append(l).toString()).append(" ORDER BY \"order\";").toString();
	 Cursor cursor = this.dex.rawQuery(string, null);
	 boolean bl = cursor.moveToFirst();
	 PokedexEntry pokedexEntry = null;
	 if (!bl) return pokedexEntry;
	 DecimalFormat df = new DecimalFormat("000");

	 String string2 = df.format(cursor.getInt(0));
	 String string3 = cursor.getString(5);
	 int n2 = cursor.getInt(6);
	 boolean bl2 = cursor.getInt(7) == cursor.getInt(8);
	 String string4 = bl2 ? cursor.getString(2) : cursor.getString(1);
	 String[] arrstring = cursor.getString(3).split(",");
	 int[] arrn = new int[arrstring.length];
	 int n3 = 0;
	 do {
	 if (n3 >= arrn.length) break;
	 arrn[n3] = Integer.parseInt((String)arrstring[n3]);
	 ++n3;
	 } while (true);
	 String[] arrstring2 = cursor.getString(4).split(",");
	 int[] arrn2 = new int[arrstring2.length];
	 do {
	 if (n >= arrn2.length) {
	 cursor.close();
	 return new PokedexEntry(l, string2, string4, arrn, arrn2, string3, n2, bl2);
	 }
	 arrn2[n] = Integer.parseInt((String)arrstring2[n])-1;
	 ++n;
	 } while (true);
	 }*/


	public void setupTypeEfficiancyMatrix() {
		setupTypeEfficiancyMatrix(6);
	}

	public void setupTypeEfficiancyMatrix(int generation) {
		Cursor c = dex.rawQuery("SELECT count(id) FROM types where id < 10000 and generation_id <= ?", new String[]{String.valueOf(generation)});
		c.moveToFirst();
		typeEfficiancy = new float[c.getInt(0)][c.getInt(0)];
		c.close();

		c = dex.rawQuery("SELECT damage_type_id, target_type_id, damage_factor FROM type_efficacy order by damage_type_id, target_type_id", null);
		while (c.moveToNext()) {
			try {
				typeEfficiancy[c.getInt(0) - 1][c.getInt(1) - 1] = c.getFloat(2) / 100;
			} catch (IndexOutOfBoundsException e) {
				e.printStackTrace();
			}
		}
		c.close();
		currentTypeGen = generation;

	}
	public float getTypeEfficiancy(int damageType, int targetType) {
		return getTypeEfficiancy(damageType, targetType, 6);
	}

	public float getTypeEfficiancy(int damageType, int targetType, int generation) {
		if (currentTypeGen != generation)
			setupTypeEfficiancyMatrix(generation);

		return typeEfficiancy[damageType][targetType];
	}


	//Moves

	public MoveListItem[] getAllMoveListItems() {
		return getAllMoveListItems(9, "");
	}

	public ArrayList<PokedexEntry> getAllPokemon() {
        ArrayList<PokedexEntry> arrayList = new ArrayList<PokedexEntry>();
        Cursor cursor = this.dex.rawQuery("SELECT pokemon_species_id, pokemon_species_id, name, (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = pokemon_species_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = pokemon_species_id GROUP BY pokemon_id), null, \"order\" FROM pokemon_species_names JOIN pokemon ON(pokemon_species_id = species_id) WHERE local_language_id = 7 AND _id < 10000", null);
        while (cursor.moveToNext()) {
            long l = cursor.getLong(0);
            String string = cursor.getString(1);
            String string2 = cursor.getString(2);
            String string3 = cursor.getString(5);
            int n = cursor.getInt(6);
            String[] statStr = cursor.getString(3).split(",");
            int[] stats = new int[statStr.length];
			for (int i=0;i < stats.length;i++) {
				stats[i] = Integer.parseInt(statStr[i]);
			}
            String[] typeStr = cursor.getString(4).split(",");
            int[] types = new int[typeStr.length];
			for (int i=0;i < types.length;i++) {
				types[i] = Integer.parseInt(typeStr[i]) - 1;
			}
			arrayList.add(new PokedexEntry(l, string, string2, stats, types, string3, n));
        }
		cursor.close();
		return arrayList;
    }

	public PokedexEntry[] getAllPokemonArray() {
        Cursor cursor = this.dex.rawQuery("SELECT pokemon_species_id, pokemon_species_id, name, (SELECT group_concat(base_stat, ',') FROM pokemon_stats WHERE pokemon_id = pokemon_species_id GROUP BY pokemon_id), (SELECT group_concat(type_id, ',') FROM pokemon_types WHERE pokemon_id = pokemon_species_id GROUP BY pokemon_id), null, \"order\" FROM pokemon_species_names JOIN pokemon ON(pokemon_species_id = species_id) WHERE local_language_id = 7 AND _id < 10000", null);
        PokedexEntry[] array = new PokedexEntry[cursor.getCount()];
		DecimalFormat df = new DecimalFormat("000");
		for (int p=0;p < array.length;p++) {
			cursor.moveToNext();
            long l = cursor.getLong(0);
            String string = df.format(cursor.getInt(1));
            String string2 = cursor.getString(2);
            String string3 = cursor.getString(5);
            int n = cursor.getInt(6);
            String[] statStr = cursor.getString(3).split(",");
            int[] stats = new int[statStr.length];
			for (int i=0;i < stats.length;i++) {
				stats[i] = Integer.parseInt(statStr[i]);
			}
            String[] typeStr = cursor.getString(4).split(",");
            int[] types = new int[typeStr.length];
			for (int i=0;i < types.length;i++) {
				types[i] = Integer.parseInt(typeStr[i]) - 1;
			}

			array[p] = new PokedexEntry(l, string, string2, stats, types, string3, n);
        }
		cursor.close();
		return array;
    }

	public MoveListItem[] getAllMoveListItems(int lang, String sortBy) {
		if (dex == null)
			return null;

		String string = new StringBuffer().append("SELECT move_id, name FROM move_names WHERE local_language_id='").append(lang).append("'; ").toString();
        Cursor cursor = this.dex.rawQuery(string, null);


		MoveListItem[] items = new MoveListItem[cursor.getCount()];
		cursor.moveToFirst();
		for (int i=0;i < items.length;i++) {
			items[i] = new MoveListItem(cursor.getInt(0), cursor.getString(1));
			cursor.moveToNext();
		}		
		cursor.close();
		return items;
	}

	public ArrayList<Move> getAllMoves(int lang) {
        ArrayList arrayList = new ArrayList();
        String string = "SELECT move_id, name, type_id, damage_class_id, power, accuracy, pp, priority, target_id, short_effect, effect_chance FROM move_names \"n\" JOIN moves \"m\" ON( n.move_id = m.id) JOIN move_effect_prose \"p\" ON(m.effect_id = p.move_effect_id) WHERE n.local_language_id= p.local_language_id AND p.local_language_id = ?' AND type_id<10000; ";
        Cursor cursor = this.dex.rawQuery(string, new String[]{String.valueOf(lang)});
        cursor.moveToFirst();
        do {
            arrayList.add(new Move(cursor.getInt(0), cursor.getString(1), cursor.getInt(2), -1 + cursor.getInt(3), cursor.getInt(4), cursor.getInt(5), cursor.getInt(6), cursor.getInt(7), cursor.getInt(8), cursor.getString(9).replaceAll("\\[\\]\\{type:(.+?)\\}", "$1").replaceAll("(\\{.*?\\})|\\[|\\]", "").replaceAll("\\$effect_chance", String.valueOf((int)cursor.getInt(10)))));
        } while (cursor.moveToNext());
        cursor.close();
        return arrayList;
    }

	public Move[] getAllMovesArray() {
		return getAllMovesArray(LANG_ID_ENGLISH);
    }

	public Move[] getAllMovesArray(int lang) {
        String string = "SELECT move_id, name, type_id, damage_class_id, power, accuracy, pp, priority, target_id, short_effect, effect_chance FROM move_names \"n\" JOIN moves \"m\" ON( n.move_id = m.id) JOIN move_effect_prose \"p\" ON(m.effect_id = p.move_effect_id) WHERE n.local_language_id= p.local_language_id AND p.local_language_id = ? AND type_id<10000 ORDER BY name; ";
        Cursor cursor = this.dex.rawQuery(string, new String[]{String.valueOf(lang)});
		Move[] array = new Move[cursor.getCount()];
		for (int i=0;i < array.length;i++) {
			cursor.moveToNext();
			array[i] = new Move(cursor.getInt(0), cursor.getString(1), cursor.getInt(2) - 1, - 1 + cursor.getInt(3), cursor.getInt(4), cursor.getInt(5), cursor.getInt(6), cursor.getInt(7), cursor.getInt(8), cursor.getString(9).replaceAll("\\[\\]\\{type:(.+?)\\}", "$1").replaceAll("(\\{.*?\\})|\\[|\\]", "").replaceAll("\\$effect_chance", String.valueOf((int)cursor.getInt(10))));
		}
		cursor.close();
        return array;
    }

	public Cursor getGameNamesCursor() {
        return this.getGameNamesCursor(9);
    }

    public Cursor getGameNamesCursor(int n) {
        SQLiteDatabase sQLiteDatabase = this.dex;
        String[] arrstring = new String[]{String.valueOf((int)n)};
        return sQLiteDatabase.rawQuery("SELECT group_concat(n.name, '/') FROM version_groups as g JOIN versions as v on(g.id = v.version_group_id) JOIN version_names as n on(v.id = n.version_id) WHERE local_language_id= ? GROUP BY g.id", arrstring);
    }

    public Move getMove(int n) {
        String string = new StringBuffer().append("SELECT move_id, name, type_id, damage_class_id, power, accuracy, pp, priority, target_id, short_effect, effect_chance FROM move_names \"n\" JOIN moves \"m\" ON( n.move_id = m.id) JOIN move_effect_prose \"p\" ON(m.effect_id = p.move_effect_id) WHERE n.local_language_id='").append(9).append("' AND p.local_language_id='").append(9).append("' AND id=").append(n).append("; ").toString();
        Cursor cursor = this.dex.rawQuery(string, null);
        boolean bl = cursor.moveToFirst();
        Move move = null;
        if (bl) {
            int n2 = cursor.getInt(0);
            String string2 = cursor.getString(1);
            int type = cursor.getInt(2) - 1;
            int n4 = -1 + cursor.getInt(3);
            int n5 = cursor.getInt(4);
            int n6 = cursor.getInt(5);
            int n7 = cursor.getInt(6);
            int n8 = cursor.getInt(7);
            int n9 = cursor.getInt(8);
            String string3 = cursor.getString(9).replaceAll("\\[\\]\\{type:(.+?)\\}", "$1").replaceAll("(\\{.*?\\})|\\[|\\]", "").replaceAll("\\$effect_chance", String.valueOf((int)cursor.getInt(10)));
            cursor.close();
            move = new Move(n2, string2, type, n4, n5, n6, n7, n8, n9, string3);
        }
        return move;
    }

	public PokedexEntry[] getPokemonArrayByCommonMove(int moveId) {
		Cursor cursor = dex.rawQuery("SELECT DISTINCT pokemon_id FROM pokemon_moves \"p\" JOIN moves \"m\" ON(p.move_id = m.id) WHERE m.id = ? AND pokemon_id < 10000", new String[]{String.valueOf(moveId)});
		PokedexEntry[] array = new PokedexEntry[cursor.getCount()];
		for (int i=0;i < array.length;i++) {
			cursor.moveToNext();
			array[i] = getPokedexEntry(cursor.getLong(0));
		}
		cursor.close();
		return array;
	}

	public ArrayList<PokedexEntry> getPokemonListByCommonMove(int n) {
        ArrayList arrayList = new ArrayList();
        Cursor cursor = this.dex.rawQuery(new StringBuffer().append(new StringBuffer().append("SELECT DISTINCT pokemon_id FROM pokemon_moves \"p\" JOIN moves \"m\" ON(p.move_id = m.id) WHERE m.id = ").append(n).toString()).append(";").toString(), null);
        if (cursor.moveToFirst()) {
            do {
                int n2;
                if ((n2 = cursor.getInt(0)) >= 1000) continue;
                arrayList.add((Object)this.getPokedexEntry(n2));
            } while (cursor.moveToNext());
        }
        cursor.close();
        return arrayList;
    }

	public PokedexListItem[] getPokemonListItemsByCommonMove(int n) {
        Cursor cursor = this.dex.rawQuery(new StringBuffer().append(new StringBuffer().append("SELECT DISTINCT pokemon_id FROM pokemon_moves \"p\" JOIN moves \"m\" ON(p.move_id = m.id) WHERE m.id = ").append(n).toString()).append(";").toString(), null);
        PokedexListItem[] items = new PokedexListItem[cursor.getCount()];
		for (int i=0;i < items.length;i++) {
			if (!cursor.moveToNext())
				break;

			items[i] = getPokedexListItem(cursor.getInt(0), LANG_ID_ENGLISH);
		}
        cursor.close();
        return items;
    }

    public ArrayList<PokedexEntry> getPokemonListByCommonMove(Move move) {
        return this.getPokemonListByCommonMove(move.getId());
    }

	public Move[] getPokemonMovesArray(int id) {
		return getPokemonMovesArray(id, VERSION_GROUP);
	}
	public Move[] getPokemonMovesArray(int id, int version) {
		return getPokemonMovesArray(id, version, LANG_ID_ENGLISH);
	}

	public Move[] getPokemonMovesArray(int id, int version, int lang) {
        String string = "SELECT move_id, name, type_id, damage_class_id, power, accuracy, pp, priority, target_id, short_effect , pokemon_move_method_id, level , effect_chance FROM move_names AS n JOIN moves AS m ON(n.move_id = m.id) JOIN move_effect_prose AS e ON(m.effect_id = e.move_effect_id) NATURAL JOIN pokemon_moves AS p WHERE n.local_language_id= e.local_language_id AND pokemon_id = ? AND e.local_language_id= ? AND  version_group_id = ? ORDER BY pokemon_move_method_id, level; ";
        Cursor cursor = this.dex.rawQuery(string, new String[]{String.valueOf(id), String.valueOf(lang), String.valueOf(version)});

		Move[] array = new Move[cursor.getCount()];
		for (int i=0;i < array.length;i++) {
			cursor.moveToNext();
			int n3 = cursor.getInt(0);
			String string2 = cursor.getString(1);
			int n4 = cursor.getInt(2);
			int n5 = -1 + cursor.getInt(3);
			int n6 = cursor.getInt(4);
			int n7 = cursor.getInt(5);
			int n8 = cursor.getInt(6);
			int n9 = cursor.getInt(7);
			int n10 = cursor.getInt(8);
			String string3 = cursor.getString(9).replaceAll("\\[\\]\\{type:(.*?)\\}", "$1").replaceAll("(\\{.*?\\})|\\[|\\]", "").replaceAll("\\$effect_chance", String.valueOf((int)cursor.getInt(12)));
			StringBuffer stringBuffer = new StringBuffer().append(MOVE_METHOD_NAMES[-1 + cursor.getInt(10)]);
			String string4 = cursor.getInt(10) == 1 ? String.valueOf((int)cursor.getInt(11)) : " ";
			array[i] = new Move(n3, string2, n4, n5, n6, n7, n8, n9, n10, string3, stringBuffer.append(string4).toString());

		}
        cursor.close();
        return array;
	}

    public ArrayList<Move> getPokemonMoves(int n) {
        return this.getPokemonMoves(n, VERSION_GROUP, LANG_ID_ENGLISH);
    }

    /*
     * Enabled aggressive block sorting
     */
    public ArrayList<Move> getPokemonMoves(int id, int version, int lang) {
        ArrayList arrayList = new ArrayList();
        String string = "SELECT move_id, name, type_id, damage_class_id, power, accuracy, pp, priority, target_id, short_effect , pokemon_move_method_id, level , effect_chance FROM move_names AS n JOIN moves AS m ON(n.move_id = m.id) JOIN move_effect_prose AS e ON(m.effect_id = e.move_effect_id) NATURAL JOIN pokemon_moves AS p WHERE n.local_language_id= e.local_language_id AND pokemon_id = ? AND e.local_language_id= ? AND  version_group_id = ? ORDER BY pokemon_move_method_id, level; ";
        Cursor cursor = this.dex.rawQuery(string, new String[]{String.valueOf(id), String.valueOf(version), String.valueOf(lang)});
        if (cursor.moveToFirst()) {
            do {
                int n3 = cursor.getInt(0);
                String string2 = cursor.getString(1);
                int n4 = cursor.getInt(2);
                int n5 = -1 + cursor.getInt(3);
                int n6 = cursor.getInt(4);
                int n7 = cursor.getInt(5);
                int n8 = cursor.getInt(6);
                int n9 = cursor.getInt(7);
                int n10 = cursor.getInt(8);
                String string3 = cursor.getString(9).replaceAll("\\[\\]\\{type:(.*?)\\}", "$1").replaceAll("(\\{.*?\\})|\\[|\\]", "").replaceAll("\\$effect_chance", String.valueOf((int)cursor.getInt(12)));
                StringBuffer stringBuffer = new StringBuffer().append(MOVE_METHOD_NAMES[-1 + cursor.getInt(10)]);
                String string4 = cursor.getInt(10) == 1 ? String.valueOf((int)cursor.getInt(11)) : " ";
                arrayList.add((Object)new Move(n3, string2, n4, n5, n6, n7, n8, n9, n10, string3, stringBuffer.append(string4).toString()));
            } while (cursor.moveToNext());
        }
        cursor.close();
        return arrayList;
    }

	public MoveListItem[] getPokemonMoveListItems(int poke) {
		return getPokemonMoveListItems(poke, VERSION_GROUP);
	}
	public MoveListItem[] getPokemonMoveListItems(int poke, int version) {
		return getPokemonMoveListItems(poke, version, LANG_ID_ENGLISH);
	}

	public MoveListItem[] getPokemonMoveListItems(int poke, int version, int lang) {
		String query = "SELECT move_id, pokemon_move_method_id AS meth, level, (SELECT name FROM move_names where local_language_id = ? AND move_id=pm.move_id) FROM pokemon_moves AS pm WHERE  pokemon_id = ? AND version_group_id= ? ORDER BY meth, level";
		Cursor c = dex.rawQuery(query, new String[]{String.valueOf(lang), String.valueOf(poke),String.valueOf(version)});
		c.moveToFirst();

		MoveListItem[] items = new MoveListItem[c.getCount()];
		for (int i=0;i < items.length;i++) {
			int id = c.getInt(0);
			String disp = MOVE_METHOD_NAMES[c.getInt(1) - 1] + (c.getInt(1) == 1 ? c.getString(2) : "");
			String name = c.getString(3);
			items[i] = new MoveListItem(id, disp, name);
			c.moveToNext();
		}
		c.close();
		return items;		
	}
	//Evolutions and Forms

	public ArrayList<ArrayList<Evolution>> getEvolutions(long l) {
        return this.getEvolutions(l, 9);
    }

    /*
     * Enabled aggressive block sorting
     */
    public ArrayList<ArrayList<Evolution>> getEvolutions(long l, int n) {
        StringBuilder stringBuilder = new StringBuilder();
        ArrayList arrayList = new ArrayList();
        stringBuilder.append("SELECT p.evolves_from_species_id, p.id");
        stringBuilder.append(", e.evolution_trigger_id");
        stringBuilder.append(", (SELECT name FROM item_names WHERE trigger_item_id = item_id AND local_language_id = ? )");
        stringBuilder.append(", e.minimum_level");
        stringBuilder.append(", (SELECT name FROM item_names WHERE held_item_id = item_id AND local_language_id = ? )");
        stringBuilder.append(", needs_overworld_rain, turn_upside_down");
        stringBuilder.append(", (SELECT identifier FROM genders WHERE id=gender_id)");
        stringBuilder.append(", group_concat((SELECT name FROM location_names WHERE location_id = e.location_id AND local_language_id = ?), ' or \n')");
        stringBuilder.append(", time_of_day");
        stringBuilder.append(", minimum_happiness");
        stringBuilder.append(", minimum_beauty");
        stringBuilder.append(", minimum_affection");
        stringBuilder.append(", (SELECT name FROM move_names WHERE move_id = known_move_id AND local_language_id = ?)");
        stringBuilder.append(", (SELECT name FROM type_names WHERE type_id = known_move_type_id AND local_language_id = ?)");
        stringBuilder.append(", (SELECT name FROM type_names WHERE type_id = party_type_id AND local_language_id = ?)");
        stringBuilder.append(", (SELECT name FROM pokemon_species_names WHERE pokemon_species_id = party_species_id AND local_language_id = ?)");
        stringBuilder.append(", (SELECT name FROM pokemon_species_names WHERE pokemon_species_id = trade_species_id AND local_language_id = ?)");
        stringBuilder.append(", relative_physical_stats");
        stringBuilder.append(" FROM pokemon_species AS p LEFT OUTER JOIN pokemon_evolution AS e ON(p.id= e.evolved_species_id)");
        stringBuilder.append("WHERE evolution_chain_id = (SELECT evolution_chain_id FROM pokemon_species WHERE id = ? )");
        stringBuilder.append("GROUP BY p.id ORDER BY \"order\";");
        SQLiteDatabase sQLiteDatabase = this.dex;
        String string = stringBuilder.toString();
        String[] arrstring = new String[]{String.valueOf((int)n), String.valueOf((int)n), String.valueOf((int)n), String.valueOf((int)n), String.valueOf((int)n), String.valueOf((int)n), String.valueOf((int)n), String.valueOf((int)n), String.valueOf((long)l)};
        Cursor cursor = sQLiteDatabase.rawQuery(string, arrstring);
        if (cursor.moveToFirst()) {
            do {
                long l2 = cursor.getLong(1);
                StringBuilder stringBuilder2 = new StringBuilder();
                if (cursor.getInt(0) != 0) {
                    ArrayList arrayList2 = (ArrayList)arrayList.get(-1 + arrayList.size());
                    int n2 = cursor.getInt(4);
                    stringBuilder2.append(new StringBuffer().append('\uffeb').append("\n").toString());
                    String string2 = cursor.getInt(2) != 3 ? new StringBuffer().append(EVOLVE_METHODS[cursor.getInt(2)]).append("\n").toString() : new StringBuffer().append(cursor.getString(3)).append("\n").toString();
                    stringBuilder2.append(string2);
                    if (n2 > 0) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("at lvl ").append(n2).toString()).append("\n").toString());
                    }
                    if (cursor.getString(5) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("holding ").append(cursor.getString(5)).toString()).append("\n").toString());
                    }
                    if (cursor.getInt(6) != 0) {
                        stringBuilder2.append("while raining \n");
                    }
                    if (cursor.getInt(7) != 0) {
                        stringBuilder2.append("while 3DS is upside down \n");
                    }
                    if (cursor.getString(8) != null) {
                        stringBuilder2.append(new StringBuffer().append(cursor.getString(8)).append("\n").toString());
                    }
                    if (cursor.getString(9) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("at ").append(cursor.getString(9)).toString()).append("\n").toString());
                    }
                    if (cursor.getString(10) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("during the ").append(cursor.getString(10)).toString()).append("\n").toString());
                    }
                    if (cursor.getInt(11) != 0) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("with at least ").append(cursor.getInt(11)).toString()).append(" happiness \n").toString());
                    }
                    if (cursor.getInt(12) != 0) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("with at least ").append(cursor.getInt(12)).toString()).append(" beauty \n").toString());
                    }
                    if (cursor.getInt(13) != 0) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("with at least ").append(cursor.getInt(13)).toString()).append(" affection \n").toString());
                    }
                    if (cursor.getString(14) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("knowing ").append(cursor.getString(14)).toString()).append("\n").toString());
                    }
                    if (cursor.getString(15) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("knowing a  ").append(cursor.getString(15)).toString()).append(" type move\n").toString());
                    }
                    if (cursor.getString(16) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("with a ").append(cursor.getString(16)).toString()).append(" type in the party\n").toString());
                    }
                    if (cursor.getString(17) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("with a ").append(cursor.getString(17)).toString()).append(" in the party \n").toString());
                    }
                    if (cursor.getString(18) != null) {
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("for a ").append(cursor.getString(18)).toString()).append(" \n").toString());
                    }
                    if (cursor.getString(19) != null) {
                        String[] arrstring2 = new String[3];
						arrstring2[0] = "<";
                        arrstring2[1] = "=";
                        arrstring2[2] = ">";
                        stringBuilder2.append(new StringBuffer().append(new StringBuffer().append("with Attack ").append(arrstring2[1 + cursor.getInt(19)]).toString()).append(" Defense \n").toString());
                    }
                    if ((long)cursor.getInt(0) == ((Evolution)arrayList2.get(-1 + arrayList2.size())).getEvolutionId()) {
                        arrayList2.add((Object)new Evolution(l2, stringBuilder2.toString()));
                        continue;
                    }
                    ArrayList arrayList3 = new ArrayList();
                    arrayList.add((Object)arrayList3);
                    do {
                        arrayList3.add((Object)((Evolution)arrayList2.get(arrayList3.size())));
                    } while ((long)cursor.getInt(0) != ((Evolution)arrayList2.get(-1 + arrayList3.size())).getEvolutionId());
                    arrayList3.add((Object)new Evolution(l2, stringBuilder2.toString()));
                    continue;
                }
                arrayList.add((Object)new ArrayList());
                ((ArrayList)arrayList.get(-1 + arrayList.size())).add((Object)new Evolution(l2, stringBuilder2.toString()));
            } while (cursor.moveToNext());
        }
        cursor.close();
        return arrayList;
    }

    public ArrayList<ArrayList<Evolution>> getEvolutions(PokedexEntry pokedexEntry) {
        return this.getEvolutions(pokedexEntry.getId());
    }

    public int[] getFormIds(long l) {
        String string = "SELECT _id FROM pokemon WHERE species_id != _id AND species_id = ?";
        Cursor cursor = this.dex.rawQuery(string, new String[]{String.valueOf(l)});
        int[] arrn = new int[cursor.getCount()];
        if (cursor.moveToFirst()) {
            do {
                arrn[cursor.getPosition()] = cursor.getInt(0);
            } while (cursor.moveToNext());
        }
		Log.e("AAA", Arrays.toString(arrn));
        return arrn;
    }




//
	//Veekun's pokedex setup

	//The Android's default system path of your application database.


	private final Context myContext;

	/**
	 * Constructor
	 * Takes and keeps a reference of the passed context in order to access to the application assets and resources.
	 * @param context
	 */


	/**
	 * Creates a empty database on the system and rewrites it with your own database.
	 * */
	public void createDataBase() throws IOException {

		boolean dbExist = checkDataBase();

		if (dbExist) {
			//do nothing - database already exist
		} else {

			//By calling this method and empty database will be created into the default system path
			//of your application so we are gonna be able to overwrite that database with our database.
			this.getReadableDatabase();

			try {

				copyDataBase();

			} catch (IOException e) {

				throw new Error("Error copying database");

			}
		}

	}

	/**
	 * Check if the database already exist to avoid re-copying the file each time you open the application.
	 * @return true if it exists, false if it doesn't
	 */
	public boolean checkDataBase() {

		SQLiteDatabase checkDB = null;

		try {
			String myPath = DB_PATH + DB_NAME;
			checkDB = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);
			getAllPokedexListItems();

		} catch (SQLiteException e) {

			return false;

		}

		if (checkDB != null) {

			checkDB.close();

		}

		return checkDB != null ? true : false;
	}

	/**
	 * Copies your database from your local assets-folder to the just created empty database in the
	 * system folder, from where it can be accessed and handled.
	 * This is done by transfering bytestream.
	 * */
	private void copyDataBase() throws IOException {

		//Open your local db as the input stream
		InputStream myInput = myContext.getAssets().open(DB_NAME);

		// Path to the just created empty db
		String outFileName = DB_PATH + DB_NAME;

		//Open the empty db as the output stream
		OutputStream myOutput = new FileOutputStream(outFileName);

		//transfer bytes from the inputfile to the outputfile
		byte[] buffer = new byte[1024];
		int length;
		while ((length = myInput.read(buffer)) > 0) {
			myOutput.write(buffer, 0, length);
		}

		//Close the streams
		myOutput.flush();
		myOutput.close();
		myInput.close();

	}

	public void openDataBase() throws SQLException {

		//Open the database
        if(!checkDataBase()){
            try {
                copyDataBase();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

		String myPath = DB_PATH + DB_NAME;
		dex = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);

	}

	@Override
	public void close() {

		if (dex != null)
			dex.close();

		super.close();

	}

	@Override
	public void onCreate(SQLiteDatabase db) {

	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

	}

	// Add your public helper methods to access and get content from the database.
	// You could return cursors by doing "return myDataBase.query(....)" so it'd be easy
	// to you to create adapters for your views.


}
